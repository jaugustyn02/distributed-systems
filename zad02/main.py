# Topic
#
# The goal of the task is to create a simple web service implementing a complex functionality based on open services providing REST APIs. You are to create a service that:
#
# provides the client with a static HTML page with a form to collect request parameters,
# receives a request from the client,
# queries a public service (different endpoints), preferably several services, for the data needed to construct the response,
# processes the received responses (e.g., calculating averages, finding extremes, comparing values from different services, etc.),
# generates and sends the response to the client (static HTML page with the results).
#
# The choice of functionality to be implemented and the services used is left to your imagination, interests, and common sense. For example:
# The client provides a city and a time period ('dates from/to' or 'last n days'), the server queries a publicly available weather service for temperatures on specific days, calculates the average, finds extremes, and sends all values to the client (i.e., a simple page with this data). Alternatively, the server queries multiple weather services and provides differences in the forecasts.
# Usually, weather forecasts or currency exchange rates win, but I count on showing greater creativity ;-) You can find a list of various public APIs at https://publicapis.dev/
# Requirements (once again, in more detail)
#
# The client (browser) should send a request based on the data from the form (static HTML) and receive a response in the form of a simple web page generated by the created service. Using plain HTML without styling, without additional frontend libraries is sufficient (it is not part of the evaluation). It doesn't have to be beautiful, it has to work.
# The created service should make multiple requests (e.g., for different data, to several services, etc.). Let your solution not be just a proxy to one existing service and provide additional logic (this will be part of the evaluation, preferably 2 or more).
# The response to the client must be generated by the server based on: 1) REST requests to public services and 2) local processing of obtained responses.
# The server should run on its own application server operating outside of an IDE (or similar technology).
# An additional (but optional) asset is to expose the service in the cloud (e.g., Heroku). This is for interested parties and is not subject to the basic evaluation.
# It is permissible to implement the task in any chosen language/technology (of course, Python and FastAPI are suggested). However, please maintain a similar level of abstraction (direct operation on HTTP requests/responses, control of data generation/reception).
# The server providing the API must comply with REST.
# Implementation of API security elements is part of the evaluation.
# We choose open services or those with limited but free access, e.g., using developer codes.
# Additionally (this is part of the evaluation): Prepare a test of HTTP requests using Postman/SwaggerUI (client-server and server-public_service). Please have them saved for submission.
#
# What to pay attention to?
#
# (!!) handling (a)synchronicity of server requests to external services (e.g., promises),
# (!) handling errors and responses from services (e.g., if there is a communication error with an external service, generate an appropriate message to the client, not a 501 Internal server error),
# validation of data entered by the client/accepted by the server.
#
# Scoring (0-10 points)
#
# arduino
#
# Server implementation - handling requests to an external service: [0-2] pts.
# Server implementation - receiving client requests compliant with REST, generating and sending responses: [0-2] pts.
# Server implementation - handling asynchronous requests and errors [0-3]
# Client implementation - static query form / response page: [0-2] pts.
# Testing REST requests using Postman/Swagger UI (to the server and to the external service): [0-1] pts.

# Project idea
#
# I want to use IMDb and MDBList APIs to get ratings of user selected movie and compare them.
# The user will input the name of the movie and the server will return the average rating of the movie from both services and the difference between the ratings.
# Server must handle errors and responses from the services and validate the data entered by the client.
# Api keys are in the .env file.

# what endpoints do I need?
# /find_movie - GET - returns a form to input the movie title
# /movie_rate - POST - returns the average rating of the movie from both services and the difference between the ratings

import os
from fastapi import FastAPI, Request, Form, HTTPException
from fastapi.responses import HTMLResponse, JSONResponse, PlainTextResponse
from dotenv import load_dotenv
import httpx

load_dotenv()

app = FastAPI()

# RapidAPI keys
rapidapi_imdb_key = os.getenv("IMDB_API_KEY")
rapidapi_mdblist_key = os.getenv("MDBLIST_API_KEY")

@app.get("/")
async def root():
    return {"message": "Hello World"}

# Error handling
@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return PlainTextResponse(str(exc.detail), status_code=exc.status_code)

# Fetch IMDb title ID asynchronously
async def fetch_imdb_title_id(title: str):
    url = "https://imdb146.p.rapidapi.com/v1/find/"
    querystring = {"query": title}
    headers = {
        "X-RapidAPI-Key": rapidapi_imdb_key,
        "X-RapidAPI-Host": "imdb146.p.rapidapi.com"
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, headers=headers, params=querystring)
            response.raise_for_status()
            data = response.json()
            results = data.get("titleResults").get("results")
            if not results:
                print(f"Movie not found: {title}")
                return None
            imdb_title_id = results[0].get("id")
            return imdb_title_id
        except (httpx.RequestError, IndexError, KeyError) as e:
            print(f"Error fetching data from IMDB API: {e}")
            return None

# Fetch IMDb rating asynchronously
async def fetch_imdb_rating(title_id: str):
    url = f"https://imdb146.p.rapidapi.com/v1/title/"
    querystring = {"id": title_id}
    headers = {
        "X-RapidAPI-Key": rapidapi_imdb_key,
        "X-RapidAPI-Host": "imdb146.p.rapidapi.com"
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, headers=headers, params=querystring)
            response.raise_for_status()
            data = response.json()
            ratingsSummary = data.get("ratingsSummary")
            rating = ratingsSummary.get("aggregateRating")
            vote_count = ratingsSummary.get("voteCount")
            print("IMDB rating: ", rating, "Vote count: ", vote_count)
            return rating
        except (httpx.RequestError, KeyError) as e:
            print(f"Error fetching data from IMDB API: {e}")
            return None
# Fetch MDBList rating asynchronously
async def fetch_mdblist_ratings(title_id: str):
    url = "https://mdblist.p.rapidapi.com/"
    querystring = {"i": title_id}
    headers = {
        "x-api-key": rapidapi_mdblist_key
    }
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, headers=headers, params=querystring)
            response.raise_for_status()
            data = response.json()
            rating = data.get("rating")
            print("MDBList rating: ", rating)
            return rating
        except (httpx.RequestError, KeyError) as e:
            print(f"Error fetching data from MDBList API: {e}")
            return None

# Movie rate endpoint
@app.post("/movie_rate", response_class=JSONResponse)
async def movie_rate(request: Request, title: str = Form(...)):
    imdb_title_id = await fetch_imdb_title_id(title)
    if imdb_title_id:
        imdb_rating = await fetch_imdb_rating(imdb_title_id)
        mdblist_rating = await fetch_mdblist_ratings(imdb_title_id)
    else:
        imdb_rating = None
        mdblist_rating = None
    return {"imdb_rating": imdb_rating, "mdblist_rating": mdblist_rating}

# Form endpoint
@app.get("/find_movie", response_class=HTMLResponse)
async def movie_form(request: Request):
    return """
    <html>
        <head>
            <title>Movie Rating Comparison</title>
        </head>
        <body>
            <h1>Movie Rating Comparison</h1>
            <form method="post" action="/movie_rate">
                <label for="title">Enter the title of the movie:</label><br>
                <input type="text" id="title" name="title"><br>
                <input type="submit" value="Submit">
            </form>
        </body>
    </html>
    """

